<?php

/**
 * @file
 * Main file for linkit module.
 * @todo Provide help
 */

/**
 * This attribute or plugin is enabled.
 */
define('LINKIT_ENABLED', 1);

/**
 * This attribute or plugin is disabled.
 */
define('LINKIT_DISABLED', 0);

/**
 * The default weight for attributes and plugins.
 */
define('LINKIT_DEFAULT_WEIGHT', 0);

/**
 * The default profile machine name
 */
define('LINKIT_DEFAULT_PRFOLE_MACHINE_NAME', 'default');


/**
 * Implements hook_menu().
 */
function linkit_menu() {
  $items = array();

  $items['linkit/dashboard/%'] = array(
    'title' => 'Linkit',
    'description' => 'Dashboard',
    'page callback' => '_linkit_dashboard',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'page arguments' => array(2),
    'theme callback' => '_linkit_dashboard_theme',
  );

  $items['linkit/autocomplete'] = array(
    'title' => 'Linkit autocomplete response function',
    'page callback' => '_linkit_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/content/linkit'] = array(
    'title' => 'Linkit profiles',
    'description' => 'Manage internal linking and control what results are shown in the autocomplete search.',
    'page callback' => 'linkit_admin_page',
    'access arguments' => array('administer linkit'),
    'file' => 'linkit.admin.inc',
  );

  $items['admin/config/content/linkit/profile/add'] = array(
    'title' => 'Add new Linkit profile',
    'page callback' => 'linkit_admin_profile_page',
    'access arguments' => array('administer linkit'),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
    'file' => 'linkit.admin.inc',
  );

  $items['admin/config/content/linkit/profile/%linkit_profile'] = array(
    'title callback' => 'linkit_admin_profile_title',
    'title arguments' => array('Edit', 5),
    'page callback' => 'linkit_admin_profile_page',
    'page arguments' => array(5),
    'access arguments' => array('administer linkit'),
    'file' => 'linkit.admin.inc',
  );

  $items['admin/config/content/linkit/profile/%linkit_profile/delete'] = array(
    'title' => 'Delete Linkit profile',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('linkit_profile_delete_form', 5),
    'access callback' => 'linkit_admin_profile_delete_access',
    'access arguments' => array(5),
    'file' => 'linkit.admin.inc',
  );

  return $items;
}

/**
 * Return the theme name to be used when showing linkit dashboard
 */
function _linkit_dashboard_theme() {
  return variable_get('admin_theme', 'seven');
}

/**
 * Implements hook_permission().
 */
function linkit_permission() {
  return array(
    'administer linkit' => array(
      'title' => t('Administer Linkit'),
    ),
  );
}

/**
 * Menu access callback; Make the default profile undeletable.
 */
function linkit_admin_profile_delete_access($profile) {
  if(user_access('administer linkit') && isset($profile['machine_name']) && $profile['machine_name'] != LINKIT_DEFAULT_PRFOLE_MACHINE_NAME) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_theme().
 */
function linkit_theme($existing, $type, $theme, $path) {
  return array(
    'linkit_dashboard' => array(
      'variables' => array('form' => NULL),
      'template' => 'linkit-dashboard',
    ),
    'linkit_profile_assignment' => array(
      'render element' => 'form',
    ),
    'linkit_profile_form' => array(
      'render element' => 'form',
      'file' => 'linkit.admin.inc',
    ),
  );
}

/**
 * Implements hook_element_info_alter().
 */
function linkit_element_info_alter(&$types) {
  if (isset($types['text_format']['#pre_render']) && is_array($types['text_format']['#pre_render'])) {
    if (in_array('ckeditor_pre_render_text_format', $types['text_format']['#pre_render'])) {
      _linkit_add_settings('ckeditor');
    }
  }
}

/**
 * Implements hook_ckeditor_plugin().
 */
function linkit_ckeditor_plugin() {
  return array(
    'linkit' => array(
      // Name of the plugin used to write it
      'name' => 'Linkit',
      // Description of plugin - it would appear in plugins managment of profile settings
      'desc' => t('Support for Linkit module'),
      // The full path to the CKEditor plugin directory, with trailing slash.
      'path' => drupal_get_path('module', 'linkit') . '/editors/ckeditor/',
    )
  );
}

/**
 * Template preprocess function for theme_linkit_dashboard().
 */
function template_preprocess_linkit_dashboard(&$variables) {
  // Construct page title
  $variables['head_title']        = t('Linkit dashboard');
  $variables['head']              = drupal_get_html_head();
  $variables['help']              = theme('help');
  $variables['language']          = $GLOBALS['language'];
  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';
  $variables['messages']          = isset($variables['show_messages']) ? theme('status_messages') : '';
  $variables['css']               = drupal_add_css();
  $variables['styles']            = drupal_get_css();
  $variables['scripts']           = drupal_get_js();
}

/**
 * Creates the dashboard.
 */
function _linkit_dashboard($editor) {
  module_invoke('admin_menu', 'suppress');

  // Better Autocomplete
  drupal_add_js(drupal_get_path('module', 'linkit') . '/better-autocomplete/jquery.better-autocomplete.js', array('group' => JS_LIBRARY));
  drupal_add_css(drupal_get_path('module', 'linkit') . '/better-autocomplete/better-autocomplete.css');

  drupal_add_css(drupal_get_path('module', 'linkit') . '/css/linkit.css');

  $settings['autocompletePath'] = url('linkit/autocomplete', array('query' => array('s' => ''), 'absolute' => TRUE));

  // TODO: Condition: if files plugin is enabled
  // Check if IMCE is enbled and accessable
  if (module_invoke('imce', 'access')) {
    $settings['IMCEurl'] = url('imce', array('query' => array(
      'app' => 'Linkit|sendto@Drupal.linkit.IMCECallback',
      'absolute' => TRUE,
    )));
    $settings['publicFilesDirectory'] = variable_get('file_public_path', conf_path() . '/files');
  }

  $profile = linkit_get_dashboard_profile();
  if (isset($profile['advanced'])) {
    $settings['advanced'] = array_filter($profile['advanced']);
  }

  drupal_add_js(array('linkit' => $settings), 'setting');
  drupal_add_js(drupal_get_path('module', 'linkit') . '/linkit.js');

  switch ($editor) {
    case 'wysiwyg_tinymce':
      // Add JavaScript.
      drupal_add_js(wysiwyg_get_path('tinymce') . '/jscripts/tiny_mce/tiny_mce_popup.js');
      drupal_add_js(drupal_get_path('module', 'linkit') . '/editors/tinymce/linkit.js');
      break;

    case 'ckeditor':
    case 'wysiwyg_ckeditor':
      // Add JavaScript.
      drupal_add_js(drupal_get_path('module', 'linkit') . '/editors/ckeditor/linkitDialog.js');
      break;

    case 'fckeditor':
    case 'wysiwyg_fckeditor':
      // Add JavaScript.
      drupal_add_js(drupal_get_path('module', 'linkit') . '/editors/fckeditor/linkit/linkitDialog.js');
      break;
  }
  $form = drupal_get_form('linkit_dashboard_form');
  print theme('linkit_dashboard', array('form' => render($form)));
}

/**
 * Autocomplete callback function.
 */
function _linkit_autocomplete($search = NULL) {
  $search = check_url($_GET['s']);

  $url = parse_url($search);
  $enabled_plugins = linkit_get_profile_plugins();

  // Absolute URL
  if ($result = _linkit_result_from_url($search, $enabled_plugins)) {
    $results = array($result);
  }
  elseif (!$results = _linkit_autocomplete_search($search, $enabled_plugins)) {
    $results = array(array(
      'title' => t('No results'),
      'addClass' => 'status-notice',
      'disabled' => TRUE,
    ));
  }
  drupal_json_output($results);
}

/**
 * Perform internal autocomplete search
 * Enter description here ...
 * @param $search The search string
 * @return $results An array with the result objects
 */
function _linkit_autocomplete_search($search, $enabled_plugins) {
  $matches = array();
  if ($search) {
    $profile = linkit_get_dashboard_profile();
    foreach ($enabled_plugins AS $name => $plugin) {
      // The function should exist, maybe it's better to just throw the error?
      if (isset($plugin['autocomplete callback'])) {
        $results = call_user_func($plugin['autocomplete callback'], $search, $profile);
        // TODO: Maybe validate the result?
        $matches = array_merge($matches, $results);
      }
    }
  }
  if (!empty($matches)) {
    return $matches;
  }
  return FALSE;
}

/**
 * Retrieve relevant information about a URL. Specifically this function is
 * usable for internal (absolute) URL:s, but it also works for external URL:s.
 *
 * @todo Flag for allowing relative paths, if necessary.
 * @todo Does it work with i18n?
 *
 * @param $url
 *   The url that should be scanned.
 *
 * @return $path_info
 *   An associative array containing:
 *   - url: The same as the argument $url, untouched.
 *   - target: Either "internal" or "external".
 *   - requested_path: If internal, the path requested relative to Drupal root.
 *     The only exception is when frontpage is referred directly, then it will
 *     be whatever the frontpage is set to.
 *   - system_path: If internal and the path is valid, the Drupal system path,
 *     e.g. "node/23".
 *   - alias: If internal, the alias to the path, assuming an alias exists.
 *   - query_fragment: If internal, the query and fragment of the url.
 *     Typically it is not needed for searching and is just reappended back
 *     when processing of the path is done. It could e.g. look like
 *     "?foo=bar#anchor".
 *   - safe_url: If external, and the protocol is http or https, this will be
 *     the original url, stripped from everything that could potentially be
 *     dangerous. E.g. "http://user:pass@example.org/settings?evilaction=true"
 *     will become "http://example.org/settings".
 */
function linkit_scan_url($url) {
  $parts = parse_url($url);
  if (!$parts['scheme'] || !$parts['host']) {
    // Not an absolute URL.
    return FALSE;
  }
  $path_info['url'] = $url;
  // URL to frontpage, without trailing slash
  $root_url = drupal_substr(url('<front>', array('absolute' => TRUE)), 0, -1);

  // Internal URL
  if (preg_match('~^' . preg_quote($root_url, '~') . '(?:/(.*?))?(?:$|\?|#)~', $url, $matches)) {
    $path_info['target'] = 'internal';
    // The "?foo=bar#anchor" trailing part of the URL
    $path_info['query_fragment'] = (isset($parts['query']) ? '?' . $parts['query'] : '') . (isset($parts['fragment']) ? '#' . $parts['fragment'] : '');
    if (!empty($matches[1])) {
      $path_info['requested_path'] = trim($matches[1], '/');
    }
    else {
      $path_info['frontpage'] = TRUE;
      $path_info['requested_path'] = variable_get('site_frontpage', 'node');
    }

    // Check if the path already is an alias
    if (!$processed_path = drupal_lookup_path('source', $path_info['requested_path'])) {
      // Not an alias, so keep the original value
      $processed_path = $path_info['requested_path'];
    }

    if (drupal_valid_path($processed_path)) {
      $path_info['system_path'] = $processed_path;
      if ($alias = drupal_lookup_path('alias', $path_info['requested_path'])) {
        $path_info['alias'] = $alias;
      }
    }
  }
  // External URL
  else {
    $path_info['target'] = 'external';
    if (preg_match('~^https?$~', $parts['scheme'])) {
      $path_info['safe_url'] = $parts['scheme'] . '://' . $parts['host'] . $parts['path'];
    }
  }
  return $path_info;
}

/**
 * Retrieve the result object from an absolute URL. This function calls the
 * enabled plugins' "path info callback" to look for a result object. Both
 * internal and external paths work.
 *
 * @param $url
 *   An absolute URL.
 *
 * @return
 *   A result object. This is an associative array which consists of:
 *   - title: The title of the result
 *   - description: The description of the result (may contain HTML).
 *   - path: The target path which will be inserted as the href in the link.
 *   - alias: (optional) The alias to an internal path. TODO: Add to tokens for all plugins except files.
 *   - addClass: A CSS class that will be added to the DOM result item.
 */
function _linkit_result_from_url($url, $enabled_plugins) {
  if (!$path_info = linkit_scan_url($url)) {
    return FALSE;
  }

  // Let plugins review the path and optionally return a result
  $profile = linkit_get_dashboard_profile();
  foreach ($enabled_plugins as $name => $plugin) {
    if (isset($plugin['path info callback']) && $result = call_user_func($plugin['path info callback'], $path_info, $profile)) {
      break;
    }
  }
  // A plugin gave a result
  if ($result) {
    if (!isset($result['addClass'])) {
      $result['addClass'] = 'status-ok';
    }
    if (!isset($result['path']) && $path_info['target'] == 'internal') {
      // This is default target path for internal links, can be overridden by plugins.
      $result['path'] = $path_info['system_path'] . $path_info['query_fragment'];
    }
    elseif (!isset($result['path']) && $path_info['target'] == 'external') {
      // This is default target path for external links, can be overridden by plugins.
      $result['path'] = $path_info['url'];
    }
    if (isset($path_info['frontpage']) && $path_info['frontpage'] === TRUE) {
      $result['path'] = '<front>' . $path_info['query_fragment'];
    }
    // There is no alias for front, and alias shouldn't be altered by plugins
    elseif (isset($path_info['alias'])) {
      $result['alias'] = $path_info['alias'];
    }
  }
  // No plugin results, internal, exists
  elseif (!empty($path_info['system_path'])) {
    $menu_item = menu_get_item($path_info['system_path']);
    $result = array(
      'path' => $path_info['system_path'],
      'title' => $menu_item['title'] ? check_plain($menu_item['title']) : check_plain($path_info['system_path']),
      'description' => 'This is an internal path.',
      'addClass' => 'status-ok',
    );
    if (isset($path_info['alias'])) {
      $result['alias'] = $path_info['alias'];
    }
  }
  // No plugin results, internal, doesn't exist
  elseif ($path_info['target'] == 'internal') {
    $result = array(
      'path' => $path_info['requested_path'] . $path_info['query_fragment'],
      'title' => 'Page not found',
      'description' => 'This page does not exist or you do not have access to it.',
      'addClass' => 'status-warning',
    );
  }
  // No plugin results, external
  elseif ($path_info['target'] == 'external') {
    $result = array(
      'title' => 'No information available',
      'description' => 'This is an external URL, but we don\'t know where it leads.',
      'path' => $path_info['url'],
      'addClass' => 'status-notice',
    );
  }
  return $result;
}

/**
 * Implements hook_form().
 */
function linkit_dashboard_form() {
  // Check if we have IMCE and access to it.
  $imce = module_invoke('imce', 'access');

  $form['search'] = array(
    '#type' => 'textfield',
    '#title' => t('Search content'),
    '#description' => t('Start typing to find content. Use arrow keys to navigate up and down.') . '<br />' . t('You can also paste an URL here.'),
    '#maxlength' => 255,
    '#size' => 60,
    '#default_value' => '',
    '#weight' => -10,
  );

  // TODO: Add to condition that file plugin should be enabled
  // TODO: Imce button hijacks the JS submit event for the form
  if ($imce) {
    $form['file_browser'] = array(
      '#type' => 'button',
      '#value' => t('Open file browser'),
      '#name' => 'linkit-imce',
      '#id' => 'linkit-imce',
    '#weight' => -8,
    );
    // Add extra class to edit-link field when we can use IMCE
    $form['search']['#attributes'] = array('class' => array('with_imce'));
    // Add the imce buttom
    //$form['search']['#field_suffix'] = drupal_render($imcebutton);
  }

  $form['path'] = array(
    '#type' => 'textfield',
    '#title' => t('Target path'),
    '#description' => t('Examples: <strong>node/123</strong>, <strong>http://www.example.com/path#anchor</strong>'),
    '#required' => TRUE,
    '#size' => 60,
    '#default_value' => '',
    '#weight' => -1,
  );

  $enabled_attributes = linkit_get_profile_attributes();

  // If we have enabled attributes, lets put them inside a fieldset.
  if (count($enabled_attributes)) {
    // Create the container fieldset.
    $form['attributes'] = array(
      '#type' => 'fieldset',
      '#title' => t('Attributes'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 10,
    );
    // Append the attributes info the fieldset.
    foreach ($enabled_attributes AS $name => $attribute) {
      $form['attributes'][$name] = $attribute;
    }
  }

  $form['insert'] = array(
    '#type' => 'button',
    '#value' => t('Insert link'),
    '#suffix' => '<a id="cancel" href="#">' . t('Cancel') . '</a>',
    '#weight' => 100,
  );

  return $form;
}

function linkit_wysiwyg_plugin($editor, $version) {
  $plugins = array();
  _linkit_add_settings('wysiwyg_' . $editor);

  switch ($editor) {
    case 'tinymce':
      $plugins['linkit'] = array(
        'path' => drupal_get_path('module', 'linkit') . '/editors/tinymce',
        'filename' => 'editor_plugin.js',
        'buttons' => array('linkit' => t('Linkit')),
        'url' => 'http://drupal.org/project/linkit',
        'load' => TRUE,
      );
      break;
    case 'ckeditor':
      // notice: Big "L" in the name here! important
      $plugins['Linkit'] = array(
        'path' => drupal_get_path('module', 'linkit') . '/editors/ckeditor',
        'buttons' => array('Linkit' => t('Linkit')),
        'url' => 'http://drupal.org/project/linkit',
        'load' => TRUE,
      );
      break;
    case 'fckeditor':
      $plugins['linkit'] = array(
        'path' => drupal_get_path('module', 'linkit') . '/editors/fckeditor',
        'buttons' => array('linkit' => t('Linkit')),
        'url' => 'http://drupal.org/project/linkit',
        'load' => TRUE,
      );
    break;
  }

  return $plugins;
}

function _linkit_add_settings($editor) {
  $editor_settings_added = &drupal_static(__FUNCTION__ . ':editor_settings_added', array());
  $global_settings_added = &drupal_static(__FUNCTION__ . ':global_settings_added', FALSE);

  if (!isset($editor_settings_added[$editor])) {
    $editor_settings_added[$editor] = TRUE;

    // Add popup url
    $settings = array(
      'linkit' => array('url' => array($editor => url('linkit/dashboard/' . $editor))),
    );
    drupal_add_js($settings, 'setting');
  }

  if (!$global_settings_added) {
    $global_settings_added = TRUE;

    // Add global settings for Linkit
    $settings = array(
      'linkit' => array(
        'modulepath' => drupal_get_path('module', 'linkit'),
      ),
    );
    drupal_add_js($settings, 'setting');
  }
}

/**
 * Implements hook_help().
 */
function linkit_help($path, $arg) {
  switch ($path) {
    case 'admin/config/content/linkit':
      $output = '<p>' . t('Help text here.') . '</p>';
      $output .= '<p>' . t('More help text.') . '</p>';
      return $output;
  }
}

/**
 * Determines if a profile with a given name exists.
 *
 * @param $profile_name
 *   The ID of the profile check.
 *
 * @return
 *   TRUE if the profile exists, FALSE otherwise.
 *
 * @see filter_format_load()
 */
function linkit_profile_exists($profile_name) {
  $profiles = variable_get('linkit_profiles', array());
  return isset($profiles[$profile_name]);
}

/**
 * Generate a page title.
 */
function linkit_admin_profile_title($op, $profile) {
  return $op . ' Linkit profile - ' . $profile['name'];
}

/**
 * Implements hook_image_default_styles().
 *
 * @return An array of image styles, keyed by the style name.
 */
function linkit_image_default_styles() {
  $styles = array();

  $styles['linkit_thumb'] = array(
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array('width' => 50, 'height' => 50, 'upscale' => 0),
        'weight' => 0,
      ),
    ),
  );

  return $styles;
}

/**
 *
 */
function linkit_get_attributes($profile = NULL) {
  if (is_null($profile)) {
    $profile = linkit_get_dashboard_profile();
  }

  // Let other modules implement thier own attributes.
  $attributes = module_invoke_all('linkit_attributes', $profile);

  // Let other modules alter the attributes.
  drupal_alter('linkit_attributes', $attributes);

  return $attributes;
}

/**
 * Implements hook_linkit_attributes().
 *
 * Define them like form elements.
 */
function linkit_linkit_attributes($profile) {
  $attributes['accesskey'] = array(
    '#type' => 'textfield',
    '#title' => t('Accesskey'),
    '#maxlength' => 255,
    '#size' => 40,
    '#default_value' => '',
    '#weight' => isset($profile['attributes']['accesskey']['weight']) ? $profile['attributes']['accesskey']['weight'] : 0,
  );

  $attributes['class'] = array(
    '#type' => 'textfield',
    '#title' => t('Class'),
    '#maxlength' => 255,
    '#size' => 40,
    '#default_value' => '',
    '#weight' => isset($profile['attributes']['class']['weight']) ? $profile['attributes']['class']['weight'] : 0,
  );

  $attributes['id'] = array(
    '#type' => 'textfield',
    '#title' => t('ID'),
    '#maxlength' => 255,
    '#size' => 40,
    '#default_value' => '',
    '#weight' => isset($profile['attributes']['id']['weight']) ? $profile['attributes']['id']['weight'] : 0,
  );

  $attributes['rel'] = array(
    '#type' => 'textfield',
    '#title' => t('Rel'),
    '#maxlength' => 255,
    '#size' => 40,
    '#default_value' => '',
    '#weight' => isset($profile['attributes']['rel']['weight']) ? $profile['attributes']['rel']['weight'] : 0,
  );

  $attributes['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#maxlength' => 255,
    '#size' => 40,
    '#default_value' => '',
    '#weight' => isset($profile['attributes']['title']['weight']) ? $profile['attributes']['title']['weight'] : 0,
  );

  return $attributes;
}

/**
 * Implements hook_linkit_plugins().
 */
function linkit_linkit_plugins() {
  $plugins['node'] = array(
    'title' => t('Node linking'),
    'description' => t('Extends Linkit with the ability to find nodes in the autocomplete search.'),
    'file' => drupal_get_path('module', 'linkit') . '/plugins/linkit.node.inc',
    'autocomplete callback' => '_linkit_node_autocomplete',
    'path info callback' => '_linkit_node_path_info'
  );

  $plugins['user'] = array(
    'title' => t('User linking'),
    'description' => t('Extends Linkit with the ability to find users in the autocomplete search.'),
    'file' => drupal_get_path('module', 'linkit') . '/plugins/linkit.user.inc',
    'autocomplete callback' => '_linkit_user_autocomplete',
    'path info callback' => '_linkit_user_path_info'
  );

  // TODO: Only for public files, right? There should definitely be a line on that in the description, if not in the title
  $plugins['file'] = array(
    'title' => t('File linking'),
    'description' => t('Extends Linkit with the ability to find files in the autocomplete search.'),
    'file' => drupal_get_path('module', 'linkit') . '/plugins/linkit.file.inc',
    'autocomplete callback' => '_linkit_file_autocomplete',
    'path info callback' => '_linkit_file_path_info',
  );

  $plugins['taxonomy'] = array(
    'title' => t('Taxonomy linking'),
    'description' => t('Extends Linkit with the ability to find terms in the autocomplete search.'),
    'file' => drupal_get_path('module', 'linkit') . '/plugins/linkit.taxonomy.inc',
    'autocomplete callback' => '_linkit_taxonomy_autocomplete',
    'path info callback' => '_linkit_taxonomy_path_info'
  );

  $plugins['external'] = array(
    'title' => t('External linking'),
    'description' => t('Extends Linkit with the ability to ping and retrieve information about external sites.'),
    'file' => drupal_get_path('module', 'linkit') . '/plugins/linkit.external.inc',
    'path info callback' => '_linkit_external_path_info'
  );

  return $plugins;
}

/**
 * Get all Linkit profiles.
 */
function linkit_get_profiles() {
  return variable_get('linkit_profiles', array());
}

/**
 * Get one Linkit profile.
 *
 * @param $profile_name
 *   The profile machine name.
 */
function linkit_get_profile($profile_name) {
  $profile = &drupal_static(__FUNCTION__);

  if (!isset($profile[$profile_name])) {
    $profiles = linkit_get_profiles();
    $profile[$profile_name] = isset($profiles[$profile_name]) ? $profiles[$profile_name] : array();
  }

  return $profile[$profile_name];
}

/**
 * Menu load callback;
 *
 * @param $profile_name
 *   The profile ID.
 */
function linkit_profile_load($profile_name) {
  return linkit_get_profile($profile_name);
}

/**
 * Get all enabled attributes for the profiles used on the dashboard.
 */
function linkit_get_profile_attributes() {
  $profile = linkit_get_dashboard_profile();
  $enabled_attributes = array();
  // Loop thru all attributes and build an array with all that is enabled.
  foreach (linkit_get_attributes($profile) as $name => $attribute) {
    if ($profile['attributes'][$name]['status'] == LINKIT_ENABLED) {
      $enabled_attributes[$name] = $attribute;
    }
  }
  return $enabled_attributes;
}

/**
 * Get all enabled plugins for the profiles used on the dashboard.
 */
function linkit_get_profile_plugins() {
  $installed_plugins = linkit_get_plugins();
  $profile = linkit_get_dashboard_profile();

  $enabled_plugins = array();

  // Include plugin file.
  foreach ($installed_plugins AS $name => $plugin) {
    // Only include files for plugins that is enabled in the profile for this user.
    if ($profile['plugins'][$name]['status'] == LINKIT_ENABLED) {
      $enabled_plugins[$name] = $plugin;
      if (isset($plugin['file'])) {
        if (file_exists(DRUPAL_ROOT . '/' . $plugin['file'])) {
          require_once DRUPAL_ROOT . '/' . $plugin['file'];
        }
        else {
          drupal_set_message(t('The Linkit plugin %plugin could not be loaded because the file %file was not found.', array('%plugin' => $name, '%file' => DRUPAL_ROOT . '/' . $plugin['file'])), 'error');
        }
      }
    }
  }
  return $enabled_plugins;
}

/**
 * Get all Linkit plugins.
 */
function linkit_get_plugins() {
  $plugins = module_invoke_all('linkit_plugins');
  return $plugins;
}

/**
 * Get the "best" Linkit profile based on the users roles to use on the dashboard.
 */
function linkit_get_dashboard_profile() {
  global $user;
  $best_profile = &drupal_static(__FUNCTION__);

  if (!isset($best_profile)) {
    // Get the role -> profile configuration.
    $role_profile = variable_get('linkit_roles_profiles', array());

    // Get the profiles.
    $profiles = linkit_get_profiles();

    $role_profile = array_reverse(array_filter($role_profile), TRUE);

    foreach ($role_profile AS $rid => $profile_name) {
      if (isset($user->roles[$rid])) {
        $best_profile = $profiles[$profile_name];
        break;
      }
    }
  }

  return $best_profile;
}

/**
 * Rebuild all role assignments to avoid conflicts.4
 */
function _linkit_rebuild_role_assign_settings() {
  $profiles = linkit_get_profiles();
  $drupal_roles = user_roles();
  $roles_profiles = variable_get('linkit_roles_profiles', array());

  $role_diff = array_diff_key($roles_profiles, $drupal_roles);

 // Unset all roles that does not exists.
  foreach ($role_diff AS $rid => $profile_name) {
    unset($roles_profiles[$rid]);
  }

  // Check that profiles that is assign to roles really exists.
  // If not, set the to blank (- None -).
  foreach ($roles_profiles AS $rid => $profile_name) {
    if(!isset($profiles[$profile_name])) {
      $roles_profiles[$rid] = '';
    }
  }

  // Save this.
  variable_set('linkit_roles_profiles', $roles_profiles);
}

/**
 * Implements hook_user_role_delete().
 */
function linkit_user_role_delete ($role) {
  _linkit_rebuild_role_assign_settings();
}