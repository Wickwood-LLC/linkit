<?php
/**
 * @file
 * Main file for Linkit module.
 */

/**
 * Denotes that urls should be constructed without prepending a slash.
 */
define('LINKIT_URL_METHOD_NO_SLASH', 0);

/**
 * Denotes that urls should be constructed with a prepending slash.
 */
define('LINKIT_URL_METHOD_ADD_SLASH', 1);

/**
 * Defines which query string key Better autocomplete will just.
 */
define('LINKIT_BAC_QUERY_KEY', 's');

// Include the file with the field functions.
require_once dirname(__FILE__) . '/linkit.field.inc';

/**
 * Implements hook_ctools_plugin_directory().
 */
function linkit_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/" . $plugin;
  }
  if ($module == 'linkit' && !empty($plugin)) {
    return "plugins/" . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_TYPE() to inform the plugin system that Linkit
 * owns Linkit plugin types.
 */
function linkit_ctools_plugin_type() {
  $plugins['linkit_search'] = array(
    'child plugins' => TRUE,
    'classes' => array('handler'),
  );
  $plugins['linkit_insert'] = array(
    'process' => array(
      'function' => 'linkit_insert_plugin_process',
    ),
  );
  $plugins['linkit_attribute'] = array();
  return $plugins;
}

/**
 * Provide defaults for insert pluings.
 */
function linkit_insert_plugin_process(&$plugin, $info) {
  // The plugin javascript can be just a filename or a full path,
  // in case it's just a filename, add the plugin path.
  if (!file_exists($plugin['javascript'])) {
    $plugin['javascript'] = $plugin['path'] . '/' . $plugin['javascript'];
  }
}

/**
 * Load a single Linkit profile.
 *
 * @param $name
 *   A string with the name of the profile to load.
 *
 * @return
 *   A LinkitProfile object or FALSE if no profile is found.
 */
function linkit_profile_load($name) {
  ctools_include('export');
  $result = ctools_export_load_object('linkit_profiles', 'names', array($name));
  if (isset($result[$name])) {
    return $result[$name];
  }
  return FALSE;
}

/**
 * Load all Linkit profiles.
 *
 * @return
 *   An array with LinkitProfile objects.
 */
function linkit_profile_load_all() {
  ctools_include('export');
  $profiles = ctools_export_load_object('linkit_profiles');
  return $profiles;
}

/**
 * Alter how the LinkitProfile object is created.
 *
 * @return
 *   A LinkitProfile object.
 *
 * @TODO: Can we do this better? No init function? Factory function?
 */
function linkit_profile_object_factory($schema, $data) {
  ctools_include('export');
  $export = $schema['export'];

  // Create the LinkitProfile object.
  $object = new $export['object'];

  // Call the unpack object that ctools provide to take care of unserialization
  // and potential joins.
  $object = _ctools_export_unpack_object($schema, $data, $object);

  // Call the profile init function.
  $object->init($object);
  return $object;
}

/**
 * Temporary saves the active profile. Active means that the user is working
 * with the profile in the dialog.
 *
 * @param string LinkitProfile $profile
 *   A LinkitProfile object.
 */
function linkit_set_active_profile(LinkitProfile $profile) {
  $active_profile = &drupal_static('linkit_active_profile');
  $active_profile = $profile;
}

/**
 * Get the currently active profile.
 *
 * @return
 *   A LinkitProfile object if there is one set.
 *
 * @see linkit_set_active_profile()
 */
function linkit_get_active_profile() {
  return drupal_static('linkit_active_profile');
}

/**
 * Fetch metadata for all Linkit search plugins.
 *
 * @return
 *   An array of arrays with information about all available Linkit search
 *   plugins.
 */
function linkit_search_plugin_load_all() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('linkit', 'linkit_search');
  // If you alter the plugin handler, be sure the new handler is registerd or
  // you include it in some other way.
  drupal_alter('linkit_search_plugins', $plugins);
  return $plugins;
}

/**
 * Function used by uasort to sort plugins by weight.
 */
function linkit_sort_plugins_by_weight($a, $b) {
  return $a["weight"] >= $b["weight"];
}

/**
 * Fetch metadata for one Linkit search plugin by the given name.
 *
 * @param $plugin_name
 *   A string with the name of the plugin to load.
 *
 * @return
 *   An array with information about the search plugin.
 */
function linkit_search_plugin_load($plugin_name) {
  ctools_include('plugins');
  $plugin = ctools_get_plugins('linkit', 'linkit_search', $plugin_name);
  // If you alter the plugin handler, be sure the new handler is registerd or
  // you include it in some other way.
  drupal_alter('linkit_search_plugin', $plugin);
  return $plugin;
}

/**
 * Fetch metadata for all Linkit insert plugins.
 *
 * @return
 *   An array of arrays with information about all available insert plugins.
 */
function linkit_insert_plugin_load_all() {
  ctools_include('plugins');
  // Load all insert plugins.
  $plugins = ctools_get_plugins('linkit', 'linkit_insert');
  return $plugins;
}

/**
 * Fetch metadata for one Linkit insert plugin by the given name.
 *
 * @param $plugin_name
 *   A string with the name of the plugin to load.
 *
 * @return
 *   An array with information about the insert plugin.
 */
function linkit_insert_plugin_load($plugin_name) {
  ctools_include('plugins');
  // Load all insert plugins.
  $plugins = ctools_get_plugins('linkit', 'linkit_insert', $plugin_name);
  return $plugins;
}

/**
 * Fetch metadata for all Linkit attribute plugins.
 *
 * @return
 *   An array of arrays with information about all available attribute plugins.
 */
function linkit_attribute_plugin_load_all() {
  ctools_include('plugins');
  // Load all attribute plugins.
  $attributes = ctools_get_plugins('linkit', 'linkit_attribute');
  return $attributes;
}

function linkit_attribute_plugin_load($plugin_name) {
  ctools_include('plugins');
  // Load all insert plugins.
  $plugins = ctools_get_plugins('linkit', 'linkit_attribute', $plugin_name);
  return $plugins;
}

/**
 * Implements hook_entity_info_alter();
 *
 * Control which enteties that can be used by Linkit search pluings.
 * Other modules can easy implement this hook aswell and make their enteties
 * usable with Linkit or change directly in the the hook_entity_info().
 *
 * @param $entity_info
 *   The entity info array, keyed by entity name.
 *
 * @see hook_entity_info()
 */
function linkit_entity_info_alter(&$entity_info) {
  // An array of entity names that is allowed to be used in Linkit.
  $allowed = array('node', 'user', 'taxonomy_term', 'file');

  foreach ($allowed as $entity_name) {
    if (isset($entity_info[$entity_name])) {
      $entity_info[$entity_name]['linkit'] = TRUE;
    }
  }
}

/**
 * Implements hook_linkit_plugin_entities_alter().
 *
 * The default behavior for entities is that they will use the default entity
 * search plugin class, which will provide them with the basic methods they
 * need.
 *
 * Tho there is some search plugins that will extend those basic method with
 * more advanced once, therefor the handlers for those plugins will have to be
 * changed.
 *
 * @param $plugins
 *   An array of all search plugins processed within Linkit entity plugin.
 *
 * @TODO: Rename plugin files to linkit_serach-ENTITY.class.php
 */
function linkit_linkit_search_plugin_entities_alter(&$plugins) {
  $alter_plugins = array(
    'entity:node',
    'entity:user',
    'entity:taxonomy_term',
    'entity:file',
  );

  $path = drupal_get_path('module', 'linkit') . '/plugins/linkit_search';

  foreach ($alter_plugins as $plugin) {
    if (isset($plugins[$plugin])) {
      $handler = array(
        'class' => 'LinkitSearchPlugin' . drupal_ucfirst($plugins[$plugin]['entity_type']),
        'file' => 'linkit-search-' . $plugins[$plugin]['entity_type'] . '.class.php',
        'path' => $path,
      );
      $plugins[$plugin]['handler'] = $handler;
    }
  }
}

/**
 * Implements hook_theme().
 */
function linkit_theme($existing, $type, $theme, $path) {
  return array(
    'linkit_plugin_form_table' => array(
      'render element' => 'form',
      'file' => 'includes/theme.inc',
    ),
  );
}

/**
 * Implements hook_menu_alter().
 */
function linkit_menu_alter(&$items) {
  // Override the default titles that ctools export_ui sets.
  // This way there is less code compared to define this in the plugin array.
  $items['admin/config/content/linkit/add']['title'] = 'Add new profile';
  $items['admin/config/content/linkit/import']['title'] = 'Import profiles';

  // Make tabs instead of action links.
  $items['admin/config/content/linkit/add']['type'] = MENU_LOCAL_TASK;
  $items['admin/config/content/linkit/import']['type'] = MENU_LOCAL_TASK;
}

/**
 * Implements hook_module_implements_alter().
 *
 * @TODO: Document why we are doing this.
 * @see linkit_element_info_alter().
 */
function linkit_module_implements_alter(&$implementations, $hook){
  if ($hook == 'element_info_alter') {
    $group = $implementations['linkit'];
    unset($implementations['linkit']);
    $implementations['linkit'] = $group;
  }
}

/**
 * Implements hook_element_info_alter().
 */
function linkit_element_info_alter(&$types) {
  // Append a process function for the field integration.
  foreach (linkit_get_allowed_field_elements() as $element) {
    if (isset($types[$element])) {
      $types[$element]['#process'][] = 'linkit_process_field_element';
    }
  }
}

/**
 * Implements hook_library().
 */
function linkit_library() {
  $path = drupal_get_path('module', 'linkit');

  $common = array(
    'website' => 'http://drupal.org/project/linkit',
    'version' => '7.3',
  );

  // Linkit base
  $libraries['linkit_base'] = array(
    'title' => 'Linkit base',
    'js' => array(
      $path . '/js/linkit.js' => array('group' => JS_DEFAULT),
      $path . '/js/linkit.dialog.js' => array('group' => JS_DEFAULT),
      // Add global settings for Linkit.
      array(
        'type' => 'setting',
        'data' => array('linkit' => array('foo' => 'bar')),
      ),
    ),
    'css' => array(
      $path . '/css/linkit.css' => array('group' => CSS_DEFAULT),
    ),
    'dependencies' => array(
      array('system', 'ui.dialog'),
      array('system', 'drupal.collapse'),
      array('linkit', 'linkit_bac'),
    ),
  );

  // Linkit field ui script.
  $libraries['linkit_field'] = array(
    'title' => 'Linkit Field UI',
    'js' => array(
      $path . '/js/linkit.field.js' => array('group' => JS_DEFAULT),
    ),
    'dependencies' => array(
      array('linkit', 'linkit_base'),
    ),
  );

  foreach ($libraries as &$library) {
    $library += $common;
  }

  // Linkit BAC
  // @TODO: Move this out of Linkit.
  $libraries['linkit_bac'] = array(
    'website' => 'https://github.com/betamos/Better-Autocomplete',
    'version' => '1.0',
    'title' => 'Better autocomplete',
    'js' => array(
      $path . '/better-autocomplete/jquery.better-autocomplete.js' => array('group' => JS_LIBRARY),
      array(
        'type' => 'setting',
        // ___profile___ is just a placeholder.
        'data' => array('linkit' => array('autocompletePath' => url('linkit/autocomplete/___profile___', array('query' => array(LINKIT_BAC_QUERY_KEY => ''), 'absolute' => TRUE)))),
      ),
    ),
    'css' => array(
      $path . '/better-autocomplete/better-autocomplete.css' => array('group' => CSS_DEFAULT),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_menu().
 */
function linkit_menu() {
  $items = array();

  // @TODO: Document this.
  $items['linkit/dashboard/%linkit_profile'] = array(
    'title' => 'Linkit',
    'description' => 'Dashboard',
    'page callback' => 'linkit_dashboard_page',
    'page arguments' => array(2),
    'access callback' => TRUE, // @TODO: Tell users why TRUE.
    'type' => MENU_CALLBACK,
  );

  // @TODO: Document this.
  $items['linkit/autocomplete/%linkit_profile'] = array(
    'title' => 'Linkit autocomplete response function',
    'page callback' => 'linkit_autocomplete',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
};

/**
 * Creates the dialog dashboard.
 *
 * We don't call drupal_get_form() in the menu callback as we don't want to
 * return the rendered form, we just want to print it as it is.
 *
 * @param $profile
 *   A LinkitProfile object.
 */
function linkit_dashboard_page(LinkitProfile $profile) {
  // Set the active Linkit profile.
  linkit_set_active_profile($profile);
  // Get the dashboard form.
  $form = drupal_get_form('linkit_dashboard_form');
  print drupal_render($form);
  drupal_exit();
}

/**
 * Implements hook_form().
 */
function linkit_dashboard_form($form, &$form_state) {
  // Get the active Linkit profile.
  $profile = linkit_get_active_profile();

  $form['linkit_search'] = array(
    '#type' => 'textfield',
    '#title' => t('Search'),
    '#maxlength' => 255,
    '#size' => 60,
    '#default_value' => '',
    '#weight' => -10,
    // @TODO: ATTACH BAC HERE
  );

  $form['linkit_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Target path'),
    '#required' => TRUE,
    '#maxlength' => NULL,
    '#size' => 60,
    '#default_value' => '',
    '#weight' => -1,
  );

  // If we have enabled attributes, lets put them inside a fieldset.
  if (count($profile->getAttributes())) {
    // Create the container fieldset.
    $form['linkit_attributes'] = array(
      '#type' => 'fieldset',
      '#title' => t('Attributes'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 10,
    );
    // Append the attributes info the fieldset.
    foreach ($profile->getAttributes() AS $name => $attribute) {
      // Add 'linkit_' prefix to ensure that is uniq.
      $form['linkit_attributes']['linkit_' . $name] = $attribute;
    }
  }

  $form['linkit_insert'] = array(
    '#type' => 'button',
    '#value' => t('Insert link'),
    '#suffix' => '<a id="linkit-cancel" href="#">' . t('Cancel') . '</a>',
    '#weight' => 100,
  );
  return $form;
}

/**
 * Autocomplete callback function.
 *
 * @param object $profile
 *   A LinkitProfile object.
 */
function linkit_autocomplete(LinkitProfile $profile) {
  // Set the active Linkit profile.
  linkit_set_active_profile($profile);

  // @TODO: Check if we need check_url here or if check_plain will do the work.
  $search_string = check_url($_GET[LINKIT_BAC_QUERY_KEY]);

  $results = array();

  // Let the Linkit search pluings do their job.
  $results = array_merge($results, linkit_autocomplete_search_plugins($search_string));

  // If there is results from the Linkit search pluings, dont care about
  // searching for absolute URL's results.
  if (!count($results)) {
    // Try to parse the string as an URL.
    // We will not use the drupal wrapper function drupal_pasre_url() as that
    // function should only be used for URL's that have been generated by the
    // system, and we can't be sure that this is the case here.
    $parts = parse_url(trim($search_string, '/'));

    // This seems to be an absolute URL.
    if (isset($parts['scheme']) || isset($parts['host'])) {
      $results = array_merge($results, linkit_autocomplete_absolute_url($search_string, $parts));
    }
  }

  // If there is still no results, return a "no results" array.
  if (!count($results)) {
    $results = array(
      array(
        'title' => t('No results'),
        'addClass' => 'status-notice',
        'disabled' => TRUE,
      )
    );
  }

  print drupal_json_output($results);
  drupal_exit();
}

/**
 * Perform autocomplete search with the Linkit search pluings.
 *
 * @param $search_string
 *   The search string.
 *
 * @return
 *   An array with the results objects.
 *   // @TODO: If no results?
 */
function linkit_autocomplete_search_plugins($search_string) {
  $matches = array();
  $profile = linkit_get_active_profile();

  // Get matches from all search pluings.
  foreach ($profile->getEnabledSerachPluings() as $plugin_name => $plugin) {
    $matches = array_merge($matches, $plugin->fetchResults($search_string));
  }

  return $matches;
}

/**
 * Retrieve relevant information about a URL. Specifically this function is
 * usable for internal (absolute) URL:s, but it also works for external URL:s.
 *
 * @param $search_string
 *   The search string that should be scanned.
 *
 * @return
 *   An associative array containing:
 *   - url: The same as the argument $url, untouched.
 *   - target: Either "internal" or "external".
 *   - requested_path: If internal, the path requested relative to Drupal root.
 *     The only exception is when frontpage is referred directly, then it will
 *     be whatever the frontpage is set to.
 *   - system_path: If internal and the path is valid, the Drupal system path,
 *     e.g. "node/23".
 *   - query_fragment: If internal, the query and fragment of the url.
 *     Typically it is not needed for searching and is just reappended back
 *     when processing of the path is done. It could e.g. look like
 *     "?foo=bar#anchor".
 *   - safe_url: If external, and the protocol is http or https, this will be
 *     the original url, stripped from everything that could potentially be
 *     dangerous. E.g. "http://user:pass@example.org/settings?evilaction=true"
 *     will become "http://example.org/settings".
 */
function linkit_parse_url($search_string) {
  global $base_url;

  // Make a new array, this will hold the components from parse_url() and our
  // own "Linkit" components.
  $path_info = array();

  // Append the original components from parse_url() to our array.
  $path_info += $parts;

  // Save the whole URL.
  $path_info['url'] = $search_string;

  if (!isset($path_info['query'])) {
    $path_info['query'] ='';
  }

  // Convert the query string to an array as Drupal can only handle querys as
  // arrays.
  // @see http://api.drupal.org/drupal_http_build_query
  parse_str($path_info['query'], $path_info['query']);

  // The 'q' parameter contains the path of the current page if clean URLs are
  // disabled. It overrides the 'path' of the URL when present, even if clean
  // URLs are enabled, due to how Apache rewriting rules work.
  if (isset($path_info['query']['q'])) {
    $path_info['path'] = $path_info['query']['q'];
    unset($path_info['query']['q']);
  }

  // Internal URL.
  // @TODO: Handle https and other schemes here?
  if (trim($path_info['scheme'] . '://' . $path_info['host'] . base_path(), '/') == $base_url) {
    $path_info['target'] = 'internal';

    // Remove the subdirectory name from the path if the site is installed in
    // subdirectory. It will be added again by the url() function.
    if (base_path() != "/") {
      $path_info['path'] = trim(preg_replace(base_path(), '', $path_info['path'], 1), '/');
    }

    // Trim the path from slashes.
    $path_info['path'] = trim($path_info['path'], '/');

    // If we have an empty path, and an internal target, we can assume that the
    // URL should go the the frontpage.
    if (empty($path_info['path'])) {
      $path_info['frontpage'] = TRUE;
      $path_info['path'] = variable_get('site_frontpage', 'node');
    }

    // Check if the path already is an alias.
    if (!$processed_path = drupal_lookup_path('source', $path_info['path'])) {
      // Not an alias, so keep the original value.
      $processed_path = $path_info['path'];
    }
    // Add the "real" system path (not the alias) if the current user have
    // access to the URL.
    $path_info['system_path'] = drupal_valid_path($processed_path) ? $processed_path : FALSE;
  }
  // External URL
  else {
    $path_info['target'] = 'external';
    if (preg_match('~^https?$~', $parts['scheme'])) {
      $path_info['safe_url'] = $parts['scheme'] . '://' . $parts['host'] . $parts['path'];
    }
  }

  return $path_info;
}

/**
 * Retrieve the result object from an absolute URL. Both internal and external
 * paths work.
 *
 * @param $search_string
 *   The search string.
 *
 * @return
 *   A result object. This is an associative array which consists of:
 *   - title: The title of the result
 *   - description: The description of the result (may contain HTML).
 *   - path: The target path which will be inserted as the href in the link.
 *   - addClass: A CSS class that will be added to the DOM result item.
 */
function linkit_autocomplete_absolute_url($search_string) {
  // Retrieve relevant information about the search string and if its a URL.
  $path_info = linkit_scan_url($search_string);

  if (!$path_info) {
    return FALSE;
  }

  // Do we have Clean URLS activated.
  $clean_urls = !empty($GLOBALS['conf']['clean_url']);

  // Set default options to pass with the url() function.
  $url_options = array(
    'alias' => TRUE,
  );

  // Add the URL frament.
  $url_options['fragment'] = isset($path_info['fragment']) ? $path_info['fragment'] : '';
  // Add the URL query.
  $url_options['query'] = isset($path_info['query']) ? $path_info['query'] : '';

  $result = array();

  if (isset($path_info['system_path']) && (bool) $path_info['system_path']) {
    $menu_item = menu_get_item($path_info['system_path']);
    $result = array(
      'path' => url($path_info['system_path'], $url_options),
      'title' => $menu_item['title'] ? check_plain($menu_item['title']) : check_plain($path_info['system_path']),
      'description' => 'This is an internal path.',
      'addClass' => 'status-ok',
    );
  }
  // No plugin result, but the URL seems to be internal. Either we do not have
  // access to it or it does not exists.
  elseif ($path_info['target'] == 'internal') {
    $result = array(
      'path' => url($path_info['path'], $url_options),
      'title' => 'Page not found',
      'description' => 'This page does not exist or you do not have access to it.',
      'addClass' => 'status-warning',
    );
  }
  // No plugin result, and the URL seems to be external.
  elseif ($path_info['target'] == 'external') {
    $result = array(
      'title' => 'No information available',
      'description' => 'This is an external URL, but we don\'t know where it leads.',
      'path' => $path_info['url'],
      'addClass' => 'status-notice',
    );
  }
  return $result;
}